import SourceryRuntime

extension Type {
    var initMethods: [Method] {
        methods.filter { ($0.isInitializer || $0.isFailableInitializer) && !$0.isConvenienceInitializer }
    }

    func generateStub(types: Types) -> [String] {
        var lines: [String] = []
        lines.append("\(accessLevel) extension \(name) {")

        let initMethodLines = initMethods.enumerated().map { index, method in
            generateInitMethodStub(types: types, index: index, method: method)
        }
        lines.append(contentsOf: initMethodLines.joined(separator: [.emptyLine]))

        // If we have an explicit init method the compiler won't synthesize a memberwise initialiser.
        if initMethods.isEmpty {
            lines.append(contentsOf: generateMemberwiseInitMethodStub(types: types))
        }
        lines.append("}")
        return lines
    }
}

private extension Type {
    /// Generate a stub for an initialiser that's generated by default for `structs` that don't have explicit initialisers.
    /// The init is generated based on the order of the properties of the struct.
    func generateMemberwiseInitMethodStub(types: Types) -> [String] {
        var lines: [String] = []
        lines.append("static func stub(".addingIndent())
        let availableVariables = storedVariables.filter { !$0.hasDefaultValue }
        let variableLines = availableVariables.map { variable in
            variable.generateInitAssignment(types: types).addingIndent(count: 2)
        }
        let joinedVariableLines = variableLines.joined(separator: ",\n")
        lines.append(joinedVariableLines)
        lines.append(") -> \(name) {".addingIndent())
        lines.append("\(name)(".addingIndent(count: 2))
        let variableAssignmentLines = availableVariables.map { variable in
            "\(variable.name): \(variable.name)".addingIndent(count: 3)
        }
        let joinedVariableAssignmentLines = variableAssignmentLines.joined(separator: ",\n")
        lines.append(joinedVariableAssignmentLines)
        lines.append(")".addingIndent(count: 2))
        lines.append("}".addingIndent())
        return lines
    }

    /// Generate a stub for an explicit init method. If a type has multiple init methods the stub method will be suffixed with a number.
    func generateInitMethodStub(types: Types, index: Int, method: Method) -> [String] {
        let implicitlyUnwrappedVariables = storedVariables.filter { $0.isImplicitlyUnwrappedOptional }
        var lines: [String] = []
        lines.append("static func \(stubMethodName(index: index, count: initMethods.count))(".addingIndent())
        var initParameters: [String] = method.parameters.map { $0.generateInitAssignment(types: types).addingIndent(count: 2) }
        initParameters.append(contentsOf: implicitlyUnwrappedVariables.map { $0.generateInitAssignment(types: types).addingIndent(count: 2) })
        lines.append(initParameters.joined(separator: ",\n"))
        lines.append(") -> \(name)\(method.isFailableInitializer ? "?" : "") {".addingIndent())
        let parameterNames = method.parameters.map { parameter in
            parameter.argumentLabel ?? parameter.name
        }
        lines.append(generateStubbableInit(parameterNames: parameterNames))
        lines.append("}".addingIndent())
        return lines
    }

    func generateStubbableInit(parameterNames: [String]) -> String {
        let implicitlyUnwrappedVariables = storedVariables.filter { $0.isImplicitlyUnwrappedOptional }
        let containsImplicitlyUnwrappedOptionals = !implicitlyUnwrappedVariables.isEmpty

        guard !parameterNames.isEmpty || containsImplicitlyUnwrappedOptionals else {
            return "\(name)()"
        }

        var lines: [String] = []
        let variableDeclaration = self is Struct ? "var" : "let"
        var objectInit: String = containsImplicitlyUnwrappedOptionals ? "\(variableDeclaration) object = \(name)(" : "\(name)("
        if parameterNames.isEmpty {
            objectInit.append(")")
        }
        lines.append(objectInit.addingIndent(count: 2))

        let parameterLines = parameterNames.map { "\($0): \($0)".addingIndent(count: 3) }
        lines.append(parameterLines.joined(separator: "," + .newLine))
        if !parameterLines.isEmpty {
            lines.append(")".addingIndent(count: 2))
        }

        if containsImplicitlyUnwrappedOptionals {
            let implicitUnwrappedVariableLines = implicitlyUnwrappedVariables.map { "object.\($0.name) = \($0.name)".addingIndent(count: 2) }
            lines.append(implicitUnwrappedVariableLines.joined(separator: .newLine))
            lines.append("return object".addingIndent(count: 2))
        }

        return lines.joined(separator: .newLine)
    }

    func stubMethodName(index: Int, count: Int) -> String {
        count > 1 ? "stub\(index)" : "stub"
    }
}
